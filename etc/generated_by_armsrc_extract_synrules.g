// Generated by armsrc_extract_synrules.pl version 2022-09-24
// from http://www.ada-auth.org/cgi-bin/cvsweb.cgi/ARM/source/ of Sep 24, 2022

/* Lexer oriented rules are elided (they are not converted correctly)

// 2.3
identifier : 
   identifier_start ( identifier_start | identifier_extend )*
   ;

// 2.3
identifier_start : 
     letter_uppercase
   | letter_lowercase
   | letter_titlecase
   | letter_modifier
   | letter_other
   | number_letter
   ;

// 2.3
identifier_extend : 
     mark_non_spacing
   | mark_spacing_combining
   | number_decimal
   | punctuation_connector
   ;

// 2.4
numeric_literal : decimal_literal | based_literal
   ;

// 2.4.1
decimal_literal : numeral ( DOT numeral )? ( exponent )?
   ;

// 2.4.1
numeral : digit ( ( underline )? digit )*
   ;

// 2.4.1
exponent : E ( PLUS )? numeral | E MINUS numeral
   ;

// 2.4.1
digit : 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
   ;

// 2.4.2
based_literal : 
   base # based_numeral ( DOT based_numeral )? # ( exponent )?
   ;

// 2.4.2
base : numeral
   ;

// 2.4.2
based_numeral : 
   extended_digit ( ( underline )? extended_digit )*
   ;

// 2.4.2
extended_digit : digit | A | B | C | D | E | F
   ;

// 2.5
character_literal : 'graphic_character'
   ;

// 2.6
string_literal : "( string_element )*"
   ;

// 2.6
string_element :   "" | non_quotation_mark_graphic_character
   ;

// 2.7
comment :    COMMENT ( non_end_of_line_character )*
   ;

 ****************** end of elision of lexer oriented rules */

// This is the raw output from the `armsrc_extract_synrules.pl --antlr` script.
// It is NOT a functioning grammar and is only intended as a starting point
// for further development.

// 2.8
pragma : 
    PRAGMA identifier
        ( LPAREN pragma_argument_association ( COMMA pragma_argument_association )* RPAREN )? SEMI
   ;

// 2.8
pragma_argument_association : 
     ( pragma_argument_identifier RIGHT_SHAFT )? name
   | ( pragma_argument_identifier RIGHT_SHAFT )? expression
   | pragma_argument_aspect_mark RIGHT_SHAFT name
   | pragma_argument_aspect_mark RIGHT_SHAFT expression
   ;

// 3.1
basic_declaration : 
     type_declaration | subtype_declaration
   | object_declaration | number_declaration
   | subprogram_declaration | abstract_subprogram_declaration
   | null_procedure_declaration | expression_function_declaration
   | package_declaration | renaming_declaration
   | exception_declaration | generic_declaration
   | generic_instantiation
   ;

// 3.1
defining_identifier : identifier
   ;

// 3.2.1
type_declaration :  full_type_declaration
   | incomplete_type_declaration
   | private_type_declaration
   | private_extension_declaration
   ;

// 3.2.1
full_type_declaration : 
     TYPE defining_identifier ( known_discriminant_part )? IS type_definition
        ( aspect_specification )? SEMI
   | task_type_declaration
   | protected_type_declaration
   ;

// 3.2.1
type_definition : 
     enumeration_type_definition | integer_type_definition
   | real_type_definition | array_type_definition
   | record_type_definition | access_type_definition
   | derived_type_definition | interface_type_definition
   ;

// 3.2.2
subtype_declaration : 
   SUBTYPE defining_identifier IS subtype_indication
        ( aspect_specification )? SEMI
   ;

// 3.2.2
subtype_indication :  ( null_exclusion )? subtype_mark ( constraint )?
   ;

// 3.2.2
subtype_mark : subtype_name
   ;

// 3.2.2
constraint : scalar_constraint | composite_constraint
   ;

// 3.2.2
scalar_constraint : 
     range_constraint | digits_constraint | delta_constraint
   ;

// 3.2.2
composite_constraint : 
     index_constraint | discriminant_constraint
   ;

// 3.3.1
object_declaration : 
    defining_identifier_list COLON
        ( ALIASED )? ( CONSTANT )? subtype_indication ( ASSIGN expression )?
            ( aspect_specification )? SEMI
  | defining_identifier_list COLON
        ( ALIASED )? ( CONSTANT )? access_definition ( ASSIGN expression )?
            ( aspect_specification )? SEMI
  | defining_identifier_list COLON
        ( ALIASED )? ( CONSTANT )? array_type_definition ( ASSIGN expression )?
            ( aspect_specification )? SEMI
  | single_task_declaration
  | single_protected_declaration
   ;

// 3.3.1
defining_identifier_list : 
  defining_identifier ( COMMA defining_identifier )*
   ;

// 3.3.2
number_declaration : 
     defining_identifier_list COLON CONSTANT ASSIGN static_expression SEMI
   ;

// 3.4
derived_type_definition : 
    ( ABSTRACT )? LIMITED )? NEW parent_subtype_indication
        ( ( AND interface_list )? record_extension_part )?
   ;

// 3.5
range_constraint :  RANGE range
   ;

// 3.5
range :  range_attribute_reference
   | simple_expression DOT_DOT simple_expression
   ;

// 3.5.1
enumeration_type_definition : 
    LPAREN enumeration_literal_specification ( COMMA enumeration_literal_specification )* RPAREN
   ;

// 3.5.1
enumeration_literal_specification : 
    defining_identifier | defining_character_literal
   ;

// 3.5.1
defining_character_literal : character_literal
   ;

// 3.5.4
integer_type_definition : 
    signed_integer_type_definition | modular_type_definition
   ;

// 3.5.4
signed_integer_type_definition : 
    RANGE static_simple_expression DOT_DOT static_simple_expression
   ;

// 3.5.4
modular_type_definition :     MOD static_expression
   ;

// 3.5.6
real_type_definition : 
    floating_point_definition | fixed_point_definition
   ;

// 3.5.7
floating_point_definition : 
    DIGITS static_expression ( real_range_specification )?
   ;

// 3.5.7
real_range_specification : 
    RANGE static_simple_expression DOT_DOT static_simple_expression
   ;

// 3.5.9
fixed_point_definition : 
    ordinary_fixed_point_definition | decimal_fixed_point_definition
   ;

// 3.5.9
ordinary_fixed_point_definition : 
    DELTA static_expression real_range_specification
   ;

// 3.5.9
decimal_fixed_point_definition : 
    DELTA static_expression DIGITS static_expression ( real_range_specification )?
   ;

// 3.5.9
digits_constraint : 
    DIGITS static_simple_expression ( range_constraint )?
   ;

// 3.6
array_type_definition : 
   unconstrained_array_definition | constrained_array_definition
   ;

// 3.6
unconstrained_array_definition : 
   ARRAY LPAREN index_subtype_definition ( COMMA index_subtype_definition )* RPAREN
      OF component_definition
   ;

// 3.6
index_subtype_definition : subtype_mark RANGE BOX
   ;

// 3.6
constrained_array_definition : 
   ARRAY LPAREN discrete_subtype_definition ( COMMA discrete_subtype_definition )* RPAREN
      OF component_definition
   ;

// 3.6
discrete_subtype_definition : discrete_subtype_indication | range
   ;

// 3.6
component_definition : 
   ( ALIASED )? subtype_indication
 | ( ALIASED )? access_definition
   ;

// 3.6.1
index_constraint :   LPAREN discrete_range ( COMMA discrete_range )* RPAREN
   ;

// 3.6.1
discrete_range : discrete_subtype_indication | range
   ;

// 3.7
discriminant_part : unknown_discriminant_part | known_discriminant_part
   ;

// 3.7
unknown_discriminant_part :  LPAREN BOX RPAREN
   ;

// 3.7
known_discriminant_part : 
    LPAREN discriminant_specification ( SEMI discriminant_specification )* RPAREN
   ;

// 3.7
discriminant_specification : 
   defining_identifier_list COLON ( null_exclusion )? subtype_mark
      ( ASSIGN default_expression )?
          ( aspect_specification )?
 | defining_identifier_list COLON access_definition
      ( ASSIGN default_expression )?
          ( aspect_specification )?
   ;

// 3.7
default_expression : expression
   ;

// 3.7.1
discriminant_constraint : 
    LPAREN discriminant_association ( COMMA discriminant_association )* RPAREN
   ;

// 3.7.1
discriminant_association : 
   ( discriminant_selector_name ( PIPE discriminant_selector_name )* RIGHT_SHAFT )? expression
   ;

// 3.8
record_type_definition : ( ( ABSTRACT )? TAGGED )? ( LIMITED )? record_definition
   ;

// 3.8
record_definition : 
    RECORD
       component_list
    END RECORD ( record_identifier )?
  | NULL RECORD
   ;

// 3.8
component_list : 
      component_item ( component_item )*
   | ( component_item )* variant_part
   | NULL SEMI
   ;

// 3.8
component_item : component_declaration | aspect_clause
   ;

// 3.8
component_declaration : 
   defining_identifier_list COLON component_definition ( ASSIGN default_expression )?
        ( aspect_specification )? SEMI
   ;

// 3.8.1
variant_part : 
   CASE discriminant_direct_name IS
       variant
      ( variant )*
   END CASE SEMI
   ;

// 3.8.1
variant : 
   WHEN discrete_choice_list RIGHT_SHAFT
      component_list
   ;

// 3.8.1
discrete_choice_list : discrete_choice ( PIPE discrete_choice )*
   ;

// 3.8.1
discrete_choice : 
   choice_expression | discrete_subtype_indication | range | OTHERS
   ;

// 3.9.1
record_extension_part : WITH record_definition
   ;

// 3.9.3
abstract_subprogram_declaration : 
    ( overriding_indicator )?
    subprogram_specification IS ABSTRACT
        ( aspect_specification )? SEMI
   ;

// 3.9.4
interface_type_definition : 
    ( LIMITED | TASK | PROTECTED | SYNCHRONIZED )? INTERFACE ( AND interface_list )?
   ;

// 3.9.4
interface_list : interface_subtype_mark ( AND interface_subtype_mark )*
   ;

// 3.10
access_type_definition : 
    ( null_exclusion )? access_to_object_definition
  | ( null_exclusion )? access_to_subprogram_definition
   ;

// 3.10
access_to_object_definition : 
    ACCESS ( general_access_modifier )? subtype_indication
   ;

// 3.10
general_access_modifier : ALL | CONSTANT
   ;

// 3.10
access_to_subprogram_definition : 
    ACCESS ( PROTECTED )? PROCEDURE parameter_profile
  | ACCESS ( PROTECTED )? FUNCTION parameter_and_result_profile
   ;

// 3.10
null_exclusion : NOT NULL
   ;

// 3.10
access_definition : 
    ( null_exclusion )? ACCESS ( CONSTANT )? subtype_mark
  | ( null_exclusion )? ACCESS ( PROTECTED )? PROCEDURE parameter_profile
  | ( null_exclusion )? ACCESS ( PROTECTED )? FUNCTION parameter_and_result_profile
   ;

// 3.10.1
incomplete_type_declaration : 
   TYPE defining_identifier ( discriminant_part )? ( IS TAGGED )? SEMI
   ;

// 3.11
declarative_part : ( declarative_item )*
   ;

// 3.11
declarative_item : 
    basic_declarative_item | body
   ;

// 3.11
basic_declarative_item : 
    basic_declaration | aspect_clause | use_clause
   ;

// 3.11
body : proper_body | body_stub
   ;

// 3.11
proper_body : 
    subprogram_body | package_body | task_body | protected_body
   ;

// 4.1
name : 
     direct_name | explicit_dereference
   | indexed_component | slice
   | selected_component | attribute_reference
   | type_conversion | function_call
   | character_literal | qualified_expression
   | generalized_reference | generalized_indexing
   | target_name
   ;

// 4.1
direct_name : identifier | operator_symbol
   ;

// 4.1
prefix : name | implicit_dereference
   ;

// 4.1
explicit_dereference : name DOT ALL
   ;

// 4.1
implicit_dereference : name
   ;

// 4.1.1
indexed_component : prefix LPAREN expression ( COMMA expression )* RPAREN
   ;

// 4.1.2
slice : prefix LPAREN discrete_range RPAREN
   ;

// 4.1.3
selected_component : prefix DOT selector_name
   ;

// 4.1.3
selector_name : identifier | character_literal | operator_symbol
   ;

// 4.1.4
attribute_reference : 
    prefix'attribute_designator
  | reduction_attribute_reference
   ;

// 4.1.4
attribute_designator : 
    identifier( LPAREN static_expression RPAREN )?
  | Access | Delta | Digits | Mod
   ;

// 4.1.4
range_attribute_reference :   prefix'range_attribute_designator
   ;

// 4.1.4
range_attribute_designator :   Range( LPAREN static_expression RPAREN )?
   ;

// 4.1.5
generalized_reference : reference_object_name
   ;

// 4.1.6
generalized_indexing : indexable_container_object_prefix actual_parameter_part
   ;

// 4.3
aggregate : 
    record_aggregate | extension_aggregate | array_aggregate
  | delta_aggregate | container_aggregate
   ;

// 4.3.1
record_aggregate :  LPAREN record_component_association_list RPAREN
   ;

// 4.3.1
record_component_association_list : 
    record_component_association ( COMMA record_component_association )*
  | NULL RECORD
   ;

// 4.3.1
record_component_association : 
    ( component_choice_list RIGHT_SHAFT )? expression
   | component_choice_list RIGHT_SHAFT BOX
   ;

// 4.3.1
component_choice_list : 
     component_selector_name ( PIPE component_selector_name )*
   | OTHERS
   ;

// 4.3.2
extension_aggregate : 
     LPAREN ancestor_part WITH record_component_association_list RPAREN
   ;

// 4.3.2
ancestor_part :   expression | subtype_mark
   ;

// 4.3.3
array_aggregate : 
    positional_array_aggregate | null_array_aggregate | named_array_aggregate
   ;

// 4.3.3
positional_array_aggregate : 
     LPAREN expression COMMA expression ( COMMA expression )* RPAREN
  | LPAREN expression ( COMMA expression )* COMMA OTHERS RIGHT_SHAFT expression RPAREN
  | LPAREN expression ( COMMA expression )* COMMA OTHERS RIGHT_SHAFT BOX RPAREN
  | LBRACKET expression ( COMMA expression )*( COMMA OTHERS RIGHT_SHAFT expression )? RBRACKET
  | LBRACKET expression ( COMMA expression )* COMMA OTHERS RIGHT_SHAFT BOX RBRACKET
   ;

// 4.3.3
null_array_aggregate :  LBRACKET RBRACKET
   ;

// 4.3.3
named_array_aggregate : 
     LPAREN array_component_association_list RPAREN
  | LBRACKET array_component_association_list RBRACKET
   ;

// 4.3.3
array_component_association_list : 
    array_component_association ( COMMA array_component_association )*
   ;

// 4.3.3
array_component_association : 
    discrete_choice_list RIGHT_SHAFT expression
  | discrete_choice_list RIGHT_SHAFT BOX
  | iterated_component_association
   ;

// 4.3.3
iterated_component_association : 
    FOR defining_identifier IN discrete_choice_list RIGHT_SHAFT expression
  | FOR iterator_specification RIGHT_SHAFT expression
   ;

// 4.3.4
delta_aggregate : record_delta_aggregate | array_delta_aggregate
   ;

// 4.3.4
record_delta_aggregate : 
     LPAREN base_expression WITH DELTA record_component_association_list RPAREN
   ;

// 4.3.4
array_delta_aggregate : 
     LPAREN base_expression WITH DELTA array_component_association_list RPAREN
  | LBRACKET base_expression WITH DELTA array_component_association_list RBRACKET
   ;

// 4.3.5
container_aggregate : 
    null_container_aggregate
  | positional_container_aggregate
  | named_container_aggregate
   ;

// 4.3.5
null_container_aggregate :  LBRACKET RBRACKET
   ;

// 4.3.5
positional_container_aggregate :  LBRACKET expression( COMMA expression )* RBRACKET
   ;

// 4.3.5
named_container_aggregate :  LBRACKET container_element_association_list RBRACKET
   ;

// 4.3.5
container_element_association_list : 
    container_element_association ( COMMA container_element_association )*
   ;

// 4.3.5
container_element_association : 
    key_choice_list RIGHT_SHAFT expression
  | key_choice_list RIGHT_SHAFT BOX
  | iterated_element_association
   ;

// 4.3.5
key_choice_list : key_choice ( PIPE key_choice )*
   ;

// 4.3.5
key_choice : key_expression | discrete_range
   ;

// 4.3.5
iterated_element_association : 
    FOR loop_parameter_specification( USE key_expression )? RIGHT_SHAFT expression
  | FOR iterator_specification( USE key_expression )? RIGHT_SHAFT expression
   ;

// 4.4
expression : 
     relation ( AND relation )* | relation ( AND THEN relation )*
   | relation ( OR relation )* | relation ( OR ELSE relation )*
   | relation ( XOR relation )*
   ;

// 4.4
choice_expression : 
     choice_relation ( AND choice_relation )*
   | choice_relation ( OR choice_relation )*
   | choice_relation ( XOR choice_relation )*
   | choice_relation ( AND THEN choice_relation )*
   | choice_relation ( OR ELSE choice_relation )*
   ;

// 4.4
choice_relation : 
     simple_expression ( relational_operator simple_expression )?
   ;

// 4.4
relation : 
     simple_expression ( relational_operator simple_expression )?
   | tested_simple_expression ( NOT )? IN membership_choice_list
   | raise_expression
   ;

// 4.4
membership_choice_list : membership_choice ( PIPE membership_choice )*
   ;

// 4.4
membership_choice : choice_simple_expression | range | subtype_mark
   ;

// 4.4
simple_expression : 
    ( unary_adding_operator )? term ( binary_adding_operator term )*
   ;

// 4.4
term : factor ( multiplying_operator factor )*
   ;

// 4.4
factor : primary ( EXPON primary )? | ABS primary | NOT primary
   ;

// 4.4
primary : 
    numeric_literal | NULL | string_literal | aggregate
  | name | allocator | LPAREN expression RPAREN
  | LPAREN conditional_expression RPAREN | LPAREN quantified_expression RPAREN
  | LPAREN declare_expression RPAREN
   ;

// 4.5
logical_operator :       AND | OR | XOR
   ;

// 4.5
relational_operator :   = | NE | LESSTHAN | LE | GREATERTHAN | GE
   ;

// 4.5
binary_adding_operator :    PLUS | MINUS | CONCAT
   ;

// 4.5
unary_adding_operator :    PLUS | MINUS
   ;

// 4.5
multiplying_operator :    MUL | DIV | MOD | REM
   ;

// 4.5
highest_precedence_operator :    EXPON | ABS | NOT
   ;

// 4.5.7
conditional_expression : if_expression | case_expression
   ;

// 4.5.7
if_expression : 
   IF condition THEN dependent_expression
   ( ELSIF condition THEN dependent_expression )*
   ( ELSE dependent_expression )?
   ;

// 4.5.7
condition : boolean_expression
   ;

// 4.5.7
case_expression : 
    CASE selecting_expression IS
    case_expression_alternative ( COMMA
    case_expression_alternative )*
   ;

// 4.5.7
case_expression_alternative : 
    WHEN discrete_choice_list RIGHT_SHAFT
        dependent_expression
   ;

// 4.5.8
quantified_expression : 
    FOR quantifier loop_parameter_specification RIGHT_SHAFT predicate
  | FOR quantifier iterator_specification RIGHT_SHAFT predicate
   ;

// 4.5.8
quantifier : ALL | SOME
   ;

// 4.5.8
predicate : boolean_expression
   ;

// 4.5.9
declare_expression : 
    DECLARE ( declare_item )*
    BEGIN body_expression
   ;

// 4.5.9
declare_item : object_declaration | object_renaming_declaration
   ;

// 4.5.10
reduction_attribute_reference : 
    value_sequence'reduction_attribute_designator
  | prefix'reduction_attribute_designator
   ;

// 4.5.10
value_sequence : 
     LBRACKET ( PARALLEL( LPAREN chunk_specification RPAREN )? ( aspect_specification )? )?
        iterated_element_association RBRACKET
   ;

// 4.5.10
reduction_attribute_designator : 
    reduction_identifier LPAREN reduction_specification RPAREN
   ;

// 4.5.10
reduction_specification : reducer_name COMMA initial_value_expression
   ;

// 4.6
type_conversion : 
    subtype_mark LPAREN expression RPAREN
  | subtype_mark LPAREN name RPAREN
   ;

// 4.7
qualified_expression : 
   subtype_mark' LPAREN expression RPAREN | subtype_mark'aggregate
   ;

// 4.8
allocator : 
   NEW ( subpool_specification )? subtype_indication
 | NEW ( subpool_specification )? qualified_expression
   ;

// 4.8
subpool_specification :  LPAREN subpool_handle_name RPAREN
   ;

// 5.1
sequence_of_statements : statement ( statement )* ( label )*
   ;

// 5.1
statement : 
   ( label )* simple_statement | ( label )* compound_statement
   ;

// 5.1
simple_statement : null_statement
   | assignment_statement | exit_statement
   | goto_statement | procedure_call_statement
   | simple_return_statement | entry_call_statement
   | requeue_statement | delay_statement
   | abort_statement | raise_statement
   | code_statement
   ;

// 5.1
compound_statement : 
     if_statement | case_statement
   | loop_statement | block_statement
   | extended_return_statement
   | parallel_block_statement
   | accept_statement | select_statement
   ;

// 5.1
null_statement : NULL SEMI
   ;

// 5.1
label :  LT_LT label_statement_identifier GT_GT
   ;

// 5.1
statement_identifier : direct_name
   ;

// 5.2
assignment_statement : 
   variable_name ASSIGN expression SEMI
   ;

// 5.2.1
target_name :  AT_SIGN
   ;

// 5.3
if_statement : 
    IF condition THEN
      sequence_of_statements
   ( ELSIF condition THEN
      sequence_of_statements )*
   ( ELSE
      sequence_of_statements )?
    END IF SEMI
   ;

// 5.4
case_statement : 
   CASE selecting_expression IS
       case_statement_alternative
      ( case_statement_alternative )*
   END CASE SEMI
   ;

// 5.4
case_statement_alternative : 
   WHEN discrete_choice_list RIGHT_SHAFT
      sequence_of_statements
   ;

// 5.5
loop_statement : 
   ( loop_statement_identifier COLON )?
      ( iteration_scheme )? LOOP
         sequence_of_statements
       END LOOP ( loop_identifier )? SEMI
   ;

// 5.5
iteration_scheme : WHILE condition
   | FOR loop_parameter_specification
   | FOR iterator_specification
   | ( PARALLEL ( aspect_specification )? )?
     FOR procedural_iterator
   | PARALLEL ( LPAREN chunk_specification RPAREN )? ( aspect_specification )?
     FOR loop_parameter_specification
   | PARALLEL ( LPAREN chunk_specification RPAREN )? ( aspect_specification )?
     FOR iterator_specification
   ;

// 5.5
chunk_specification : 
     integer_simple_expression
   | defining_identifier IN discrete_subtype_definition
   ;

// 5.5
loop_parameter_specification : 
   defining_identifier IN ( REVERSE )? discrete_subtype_definition
     ( iterator_filter )?
   ;

// 5.5
iterator_filter : WHEN condition
   ;

// 5.5.2
iterator_specification : 
    defining_identifier ( COLON loop_parameter_subtype_indication )? IN ( REVERSE )?
      iterator_name ( iterator_filter )?
  | defining_identifier ( COLON loop_parameter_subtype_indication )? OF
      ( REVERSE )? iterable_name ( iterator_filter )?
   ;

// 5.5.2
loop_parameter_subtype_indication : subtype_indication | access_definition
   ;

// 5.5.3
procedural_iterator : 
     iterator_parameter_specification OF iterator_procedure_call
       ( iterator_filter )?
   ;

// 5.5.3
iterator_parameter_specification : 
     formal_part
   | LPAREN defining_identifier( COMMA defining_identifier )* RPAREN
   ;

// 5.5.3
iterator_procedure_call : 
     procedure_name
   | procedure_prefix iterator_actual_parameter_part
   ;

// 5.5.3
iterator_actual_parameter_part : 
      LPAREN iterator_parameter_association ( COMMA iterator_parameter_association )* RPAREN
   ;

// 5.5.3
iterator_parameter_association : 
     parameter_association
   | parameter_association_with_box
   ;

// 5.5.3
parameter_association_with_box : 
   ( formal_parameter_selector_name RIGHT_SHAFT )? BOX
   ;

// 5.6
block_statement : 
   ( block_statement_identifier COLON )?
       ( DECLARE
            declarative_part )?
        BEGIN
            handled_sequence_of_statements
        END ( block_identifier )? SEMI
   ;

// 5.6.1
parallel_block_statement : 
    PARALLEL ( LPAREN chunk_specification RPAREN )? ( aspect_specification )? DO
       sequence_of_statements
    AND
       sequence_of_statements
   ( AND
       sequence_of_statements )*
    END DO SEMI
   ;

// 5.7
exit_statement : 
   EXIT ( loop_name )? ( WHEN condition )? SEMI
   ;

// 5.8
goto_statement : GOTO label_name SEMI
   ;

// 6.1
subprogram_declaration : 
    ( overriding_indicator )?
    subprogram_specification
        ( aspect_specification )? SEMI
   ;

// 6.1
subprogram_specification : 
    procedure_specification
  | function_specification
   ;

// 6.1
procedure_specification : 
    PROCEDURE defining_program_unit_name parameter_profile
   ;

// 6.1
function_specification : 
    FUNCTION defining_designator parameter_and_result_profile
   ;

// 6.1
designator : ( parent_unit_name DOT )?identifier | operator_symbol
   ;

// 6.1
defining_designator : 
    defining_program_unit_name | defining_operator_symbol
   ;

// 6.1
defining_program_unit_name : ( parent_unit_name DOT )?defining_identifier
   ;

// 6.1
operator_symbol : string_literal
   ;

// 6.1
defining_operator_symbol : operator_symbol
   ;

// 6.1
parameter_profile : ( formal_part )?
   ;

// 6.1
parameter_and_result_profile : 
    ( formal_part )? RETURN ( null_exclusion )? subtype_mark
  | ( formal_part )? RETURN access_definition
   ;

// 6.1
formal_part : 
    LPAREN parameter_specification ( SEMI parameter_specification )* RPAREN
   ;

// 6.1
parameter_specification : 
    defining_identifier_list COLON ( ALIASED )? mode ( null_exclusion )? subtype_mark
        ( ASSIGN default_expression )?
            ( aspect_specification )?
  | defining_identifier_list COLON access_definition
        ( ASSIGN default_expression )?
            ( aspect_specification )?
   ;

// 6.1
mode : ( IN )? | IN OUT | OUT
   ;

// 6.1.2
global_aspect_definition : 
    NULL
  | Unspecified
  | global_mode global_designator
  | LPAREN global_aspect_element( SEMI global_aspect_element )* RPAREN
   ;

// 6.1.2
global_aspect_element : 
    global_mode global_set
  | global_mode ALL
  | global_mode SYNCHRONIZED
   ;

// 6.1.2
global_mode : 
    basic_global_mode
  | extended_global_mode
   ;

// 6.1.2
basic_global_mode : IN | IN OUT | OUT
   ;

// 6.1.2
global_set : global_name ( COMMA global_name )*
   ;

// 6.1.2
global_designator : ALL | SYNCHRONIZED | global_name
   ;

// 6.1.2
global_name : object_name | package_name
   ;

// 6.3
subprogram_body : 
    ( overriding_indicator )?
    subprogram_specification
       ( aspect_specification )? IS
       declarative_part
    BEGIN
        handled_sequence_of_statements
    END ( designator )? SEMI
   ;

// 6.4
procedure_call_statement : 
    procedure_name SEMI
  | procedure_prefix actual_parameter_part SEMI
   ;

// 6.4
function_call : 
    function_name
  | function_prefix actual_parameter_part
   ;

// 6.4
actual_parameter_part : 
     LPAREN parameter_association ( COMMA parameter_association )* RPAREN
   ;

// 6.4
parameter_association : 
   ( formal_parameter_selector_name RIGHT_SHAFT )? explicit_actual_parameter
   ;

// 6.4
explicit_actual_parameter : expression | variable_name
   ;

// 6.5
simple_return_statement : RETURN ( expression )? SEMI
   ;

// 6.5
extended_return_object_declaration : 
    defining_identifier COLON ( ALIASED )? ( CONSTANT )? return_subtype_indication
        ( ASSIGN expression )?
           ( aspect_specification )?
   ;

// 6.5
extended_return_statement : 
    RETURN extended_return_object_declaration( DO
        handled_sequence_of_statements
    END RETURN )? SEMI
   ;

// 6.5
return_subtype_indication : subtype_indication | access_definition
   ;

// 6.7
null_procedure_declaration : 
   ( overriding_indicator )?
   procedure_specification IS NULL
       ( aspect_specification )? SEMI
   ;

// 6.8
expression_function_declaration : 
   ( overriding_indicator )?
   function_specification IS
        LPAREN expression RPAREN
       ( aspect_specification )? SEMI
 | ( overriding_indicator )?
   function_specification IS
       aggregate
       ( aspect_specification )? SEMI
   ;

// 7.1
package_declaration : package_specification SEMI
   ;

// 7.1
package_specification : 
    PACKAGE defining_program_unit_name
        ( aspect_specification )? IS
      ( basic_declarative_item )*
   ( PRIVATE
      ( basic_declarative_item )* )?
    END ( ( parent_unit_name DOT )?identifier )?
   ;

// 7.2
package_body : 
    PACKAGE BODY defining_program_unit_name
        ( aspect_specification )? IS
       declarative_part
   ( BEGIN
        handled_sequence_of_statements )?
    END ( ( parent_unit_name DOT )?identifier )? SEMI
   ;

// 7.3
private_type_declaration : 
   TYPE defining_identifier ( discriminant_part )? IS ( ( ABSTRACT )? TAGGED )? ( LIMITED )? PRIVATE
      ( aspect_specification )? SEMI
   ;

// 7.3
private_extension_declaration : 
   TYPE defining_identifier ( discriminant_part )? IS
     ( ABSTRACT )? ( LIMITED | SYNCHRONIZED )? NEW ancestor_subtype_indication
     ( AND interface_list )? WITH PRIVATE
       ( aspect_specification )? SEMI
   ;

// 8.3.1
overriding_indicator : ( NOT )? OVERRIDING
   ;

// 8.4
use_clause : use_package_clause | use_type_clause
   ;

// 8.4
use_package_clause : USE package_name ( COMMA package_name )* SEMI
   ;

// 8.4
use_type_clause : USE ( ALL )? TYPE subtype_mark ( COMMA subtype_mark )* SEMI
   ;

// 8.5
renaming_declaration : 
     object_renaming_declaration
   | exception_renaming_declaration
   | package_renaming_declaration
   | subprogram_renaming_declaration
   | generic_renaming_declaration
   ;

// 8.5.1
object_renaming_declaration : 
    defining_identifier ( COLON ( null_exclusion )? subtype_mark )? RENAMES object_name
        ( aspect_specification )? SEMI
  | defining_identifier COLON access_definition RENAMES object_name
        ( aspect_specification )? SEMI
   ;

// 8.5.2
exception_renaming_declaration : 
    defining_identifier COLON EXCEPTION RENAMES exception_name
      ( aspect_specification )? SEMI
   ;

// 8.5.3
package_renaming_declaration : 
    PACKAGE defining_program_unit_name RENAMES package_name
       ( aspect_specification )? SEMI
   ;

// 8.5.4
subprogram_renaming_declaration : 
    ( overriding_indicator )?
    subprogram_specification RENAMES callable_entity_name
        ( aspect_specification )? SEMI
   ;

// 8.5.5
generic_renaming_declaration : 
    GENERIC PACKAGE defining_program_unit_name RENAMES generic_package_name
        ( aspect_specification )? SEMI
  | GENERIC PROCEDURE defining_program_unit_name RENAMES generic_procedure_name
        ( aspect_specification )? SEMI
  | GENERIC FUNCTION defining_program_unit_name RENAMES generic_function_name
        ( aspect_specification )? SEMI
   ;

// 9.1
task_type_declaration : 
   TASK TYPE defining_identifier ( known_discriminant_part )?
        ( aspect_specification )? ( IS
     ( NEW interface_list WITH )?
     task_definition )? SEMI
   ;

// 9.1
single_task_declaration : 
   TASK defining_identifier
        ( aspect_specification )? ( IS
     ( NEW interface_list WITH )?
     task_definition )? SEMI
   ;

// 9.1
task_definition : 
     ( task_item )*
  ( PRIVATE
     ( task_item )* )?
  END ( task_identifier )?
   ;

// 9.1
task_item : entry_declaration | aspect_clause
   ;

// 9.1
task_body : 
   TASK BODY defining_identifier
        ( aspect_specification )? IS
     declarative_part
   BEGIN
     handled_sequence_of_statements
   END ( task_identifier )? SEMI
   ;

// 9.4
protected_type_declaration : 
  PROTECTED TYPE defining_identifier ( known_discriminant_part )?
        ( aspect_specification )? IS
     ( NEW interface_list WITH )?
     protected_definition SEMI
   ;

// 9.4
single_protected_declaration : 
  PROTECTED defining_identifier
        ( aspect_specification )? IS
     ( NEW interface_list WITH )?
     protected_definition SEMI
   ;

// 9.4
protected_definition : 
    ( protected_operation_declaration )*
( PRIVATE
    ( protected_element_declaration )* )?
  END ( protected_identifier )?
   ;

// 9.4
protected_operation_declaration :   subprogram_declaration
     | entry_declaration
     | aspect_clause
   ;

// 9.4
protected_element_declaration :   protected_operation_declaration
     | component_declaration
   ;

// 9.4
protected_body : 
  PROTECTED BODY defining_identifier
        ( aspect_specification )? IS
   ( protected_operation_item )*
  END ( protected_identifier )? SEMI
   ;

// 9.4
protected_operation_item :   subprogram_declaration
     | subprogram_body
     | null_procedure_declaration
     | expression_function_declaration
     | entry_body
     | aspect_clause
   ;

// 9.5
synchronization_kind : By_Entry | By_Protected_Procedure | Optional
   ;

// 9.5.2
entry_declaration : 
   ( overriding_indicator )?
   ENTRY defining_identifier ( LPAREN discrete_subtype_definition RPAREN )? parameter_profile
      ( aspect_specification )? SEMI
   ;

// 9.5.2
accept_statement : 
   ACCEPT entry_direct_name ( LPAREN entry_index RPAREN )? parameter_profile ( DO
     handled_sequence_of_statements
   END ( entry_identifier )? )? SEMI
   ;

// 9.5.2
entry_index : expression
   ;

// 9.5.2
entry_body : 
    ENTRY defining_identifier entry_body_formal_part
       ( aspect_specification )?
    entry_barrier IS
       declarative_part
    BEGIN
       handled_sequence_of_statements
    END ( entry_identifier )? SEMI
   ;

// 9.5.2
entry_body_formal_part :   ( LPAREN entry_index_specification RPAREN )? parameter_profile
   ;

// 9.5.2
entry_barrier :   WHEN condition
   ;

// 9.5.2
entry_index_specification : 
    FOR defining_identifier IN discrete_subtype_definition
       ( aspect_specification )?
   ;

// 9.5.3
entry_call_statement : entry_name ( actual_parameter_part )? SEMI
   ;

// 9.5.4
requeue_statement :   REQUEUE procedure_or_entry_name ( WITH ABORT )? SEMI
   ;

// 9.6
delay_statement :   delay_until_statement | delay_relative_statement
   ;

// 9.6
delay_until_statement :   DELAY UNTIL delay_expression SEMI
   ;

// 9.6
delay_relative_statement :   DELAY delay_expression SEMI
   ;

// 9.7
select_statement : 
   selective_accept
  | timed_entry_call
  | conditional_entry_call
  | asynchronous_select
   ;

// 9.7.1
selective_accept : 
  SELECT
   ( guard )?
     select_alternative
( OR
   ( guard )?
     select_alternative )*
( ELSE
   sequence_of_statements )?
  END SELECT SEMI
   ;

// 9.7.1
guard : WHEN condition RIGHT_SHAFT
   ;

// 9.7.1
select_alternative : 
   accept_alternative
  | delay_alternative
  | terminate_alternative
   ;

// 9.7.1
accept_alternative : 
  accept_statement ( sequence_of_statements )?
   ;

// 9.7.1
delay_alternative : 
  delay_statement ( sequence_of_statements )?
   ;

// 9.7.1
terminate_alternative : TERMINATE SEMI
   ;

// 9.7.2
timed_entry_call : 
  SELECT
   entry_call_alternative
  OR
   delay_alternative
  END SELECT SEMI
   ;

// 9.7.2
entry_call_alternative : 
  procedure_or_entry_call ( sequence_of_statements )?
   ;

// 9.7.2
procedure_or_entry_call : 
  procedure_call_statement | entry_call_statement
   ;

// 9.7.3
conditional_entry_call : 
  SELECT
   entry_call_alternative
  ELSE
   sequence_of_statements
  END SELECT SEMI
   ;

// 9.7.4
asynchronous_select : 
  SELECT
   triggering_alternative
  THEN ABORT
   abortable_part
  END SELECT SEMI
   ;

// 9.7.4
triggering_alternative : triggering_statement ( sequence_of_statements )?
   ;

// 9.7.4
triggering_statement : procedure_or_entry_call | delay_statement
   ;

// 9.7.4
abortable_part : sequence_of_statements
   ;

// 9.8
abort_statement :   ABORT task_name ( COMMA task_name )* SEMI
   ;

// 10.1.1
compilation : ( compilation_unit )*
   ;

// 10.1.1
compilation_unit : 
    context_clause library_item
  | context_clause subunit
   ;

// 10.1.1
library_item : ( PRIVATE )? library_unit_declaration
  | library_unit_body
  | ( PRIVATE )? library_unit_renaming_declaration
   ;

// 10.1.1
library_unit_declaration : 
     subprogram_declaration | package_declaration
   | generic_declaration | generic_instantiation
   ;

// 10.1.1
library_unit_renaming_declaration : 
   package_renaming_declaration
 | generic_renaming_declaration
 | subprogram_renaming_declaration
   ;

// 10.1.1
library_unit_body : subprogram_body | package_body
   ;

// 10.1.1
parent_unit_name : name
   ;

// 10.1.2
context_clause : ( context_item )*
   ;

// 10.1.2
context_item : with_clause | use_clause
   ;

// 10.1.2
with_clause : limited_with_clause | nonlimited_with_clause
   ;

// 10.1.2
limited_with_clause : LIMITED ( PRIVATE )? WITH library_unit_name ( COMMA library_unit_name )* SEMI
   ;

// 10.1.2
nonlimited_with_clause : ( PRIVATE )? WITH library_unit_name ( COMMA library_unit_name )* SEMI
   ;

// 10.1.3
body_stub : 
    subprogram_body_stub | package_body_stub
  | task_body_stub | protected_body_stub
   ;

// 10.1.3
subprogram_body_stub : 
    ( overriding_indicator )?
    subprogram_specification IS SEPARATE
       ( aspect_specification )? SEMI
   ;

// 10.1.3
package_body_stub : 
   PACKAGE BODY defining_identifier IS SEPARATE
      ( aspect_specification )? SEMI
   ;

// 10.1.3
task_body_stub : 
   TASK BODY defining_identifier IS SEPARATE
      ( aspect_specification )? SEMI
   ;

// 10.1.3
protected_body_stub : 
   PROTECTED BODY defining_identifier IS SEPARATE
      ( aspect_specification )? SEMI
   ;

// 10.1.3
subunit : SEPARATE LPAREN parent_unit_name RPAREN proper_body
   ;

// 11.1
exception_declaration : defining_identifier_list COLON EXCEPTION
   ( aspect_specification )? SEMI
   ;

// 11.2
handled_sequence_of_statements : 
     sequence_of_statements
  ( EXCEPTION
     exception_handler
    ( exception_handler )* )?
   ;

// 11.2
exception_handler : 
  WHEN ( choice_parameter_specification COLON )?
     exception_choice ( PIPE exception_choice )* RIGHT_SHAFT
         sequence_of_statements
   ;

// 11.2
choice_parameter_specification : defining_identifier
   ;

// 11.2
exception_choice : exception_name | OTHERS
   ;

// 11.3
raise_statement : RAISE SEMI
      | RAISE exception_name ( WITH string_expression )? SEMI
   ;

// 11.3
raise_expression : RAISE exception_name ( WITH string_simple_expression )?
   ;

// 12.1
generic_declaration : 
    generic_subprogram_declaration | generic_package_declaration
   ;

// 12.1
generic_subprogram_declaration : 
    generic_formal_part subprogram_specification
       ( aspect_specification )? SEMI
   ;

// 12.1
generic_package_declaration : 
    generic_formal_part package_specification SEMI
   ;

// 12.1
generic_formal_part : 
    GENERIC ( generic_formal_parameter_declaration | use_clause )*
   ;

// 12.1
generic_formal_parameter_declaration : 
    formal_object_declaration
  | formal_type_declaration
  | formal_subprogram_declaration
  | formal_package_declaration
   ;

// 12.3
generic_instantiation : 
     PACKAGE defining_program_unit_name IS
         NEW generic_package_name ( generic_actual_part )?
            ( aspect_specification )? SEMI
   | ( overriding_indicator )?
     PROCEDURE defining_program_unit_name IS
         NEW generic_procedure_name ( generic_actual_part )?
            ( aspect_specification )? SEMI
   | ( overriding_indicator )?
     FUNCTION defining_designator IS
         NEW generic_function_name ( generic_actual_part )?
            ( aspect_specification )? SEMI
   ;

// 12.3
generic_actual_part : 
    LPAREN generic_association ( COMMA generic_association )* RPAREN
   ;

// 12.3
generic_association : 
   ( generic_formal_parameter_selector_name RIGHT_SHAFT )? explicit_generic_actual_parameter
   ;

// 12.3
explicit_generic_actual_parameter : expression | variable_name
   | subprogram_name | entry_name | subtype_mark
   | package_instance_name
   ;

// 12.4
formal_object_declaration : 
    defining_identifier_list COLON mode ( null_exclusion )? subtype_mark
        ( ASSIGN default_expression )?
            ( aspect_specification )? SEMI
  | defining_identifier_list COLON mode access_definition
        ( ASSIGN default_expression )?
            ( aspect_specification )? SEMI
   ;

// 12.5
formal_type_declaration : 
      formal_complete_type_declaration
    | formal_incomplete_type_declaration
   ;

// 12.5
formal_complete_type_declaration : 
    TYPE defining_identifier( discriminant_part )? IS formal_type_definition
        ( OR USE default_subtype_mark )? ( aspect_specification )? SEMI
   ;

// 12.5
formal_incomplete_type_declaration : 
    TYPE defining_identifier( discriminant_part )? ( IS TAGGED )?
        ( OR USE default_subtype_mark )? SEMI
   ;

// 12.5
formal_type_definition : 
      formal_private_type_definition
    | formal_derived_type_definition
    | formal_discrete_type_definition
    | formal_signed_integer_type_definition
    | formal_modular_type_definition
    | formal_floating_point_definition
    | formal_ordinary_fixed_point_definition
    | formal_decimal_fixed_point_definition
    | formal_array_type_definition
    | formal_access_type_definition
    | formal_interface_type_definition
   ;

// 12.5.1
formal_private_type_definition :   ( ( ABSTRACT )? TAGGED )? ( LIMITED )? PRIVATE
   ;

// 12.5.1
formal_derived_type_definition :   
     ( ABSTRACT )? ( LIMITED | SYNCHRONIZED )? NEW
        subtype_mark ( ( AND interface_list )? WITH PRIVATE )?
   ;

// 12.5.2
formal_discrete_type_definition :  LPAREN BOX RPAREN
   ;

// 12.5.2
formal_signed_integer_type_definition : RANGE BOX
   ;

// 12.5.2
formal_modular_type_definition : MOD BOX
   ;

// 12.5.2
formal_floating_point_definition : DIGITS BOX
   ;

// 12.5.2
formal_ordinary_fixed_point_definition : DELTA BOX
   ;

// 12.5.2
formal_decimal_fixed_point_definition : DELTA BOX DIGITS BOX
   ;

// 12.5.3
formal_array_type_definition : array_type_definition
   ;

// 12.5.4
formal_access_type_definition : access_type_definition
   ;

// 12.5.5
formal_interface_type_definition : interface_type_definition
   ;

// 12.6
formal_subprogram_declaration : formal_concrete_subprogram_declaration
    | formal_abstract_subprogram_declaration
   ;

// 12.6
formal_concrete_subprogram_declaration : 
     WITH subprogram_specification ( IS subprogram_default )?
        ( aspect_specification )? SEMI
   ;

// 12.6
formal_abstract_subprogram_declaration : 
     WITH subprogram_specification IS ABSTRACT ( subprogram_default )?
        ( aspect_specification )? SEMI
   ;

// 12.6
subprogram_default : default_name | BOX | NULL
   ;

// 12.6
default_name : name
   ;

// 12.7
formal_package_declaration : 
    WITH PACKAGE defining_identifier IS NEW
        generic_package_name formal_package_actual_part
            ( aspect_specification )? SEMI
   ;

// 12.7
formal_package_actual_part : 
     LPAREN ( OTHERS RIGHT_SHAFT )? BOX RPAREN
  | ( generic_actual_part )?
  | LPAREN formal_package_association ( COMMA formal_package_association )* ( COMMA OTHERS RIGHT_SHAFT BOX )? RPAREN
   ;

// 12.7
formal_package_association : 
    generic_association
  | generic_formal_parameter_selector_name RIGHT_SHAFT BOX
   ;

// 13.1
aspect_clause : attribute_definition_clause
      | enumeration_representation_clause
      | record_representation_clause
      | at_clause
   ;

// 13.1
local_name : direct_name
      | direct_name'attribute_designator
      | library_unit_name
   ;

// 13.1.1
aspect_specification : 
   WITH aspect_mark ( RIGHT_SHAFT aspect_definition )? ( COMMA
           aspect_mark ( RIGHT_SHAFT aspect_definition )? )*
   ;

// 13.1.1
aspect_mark : aspect_identifier( 'Class )?
   ;

// 13.1.1
aspect_definition : 
    name | expression | identifier
  | aggregate | global_aspect_definition
   ;

// 13.3
attribute_definition_clause : 
      FOR local_name'attribute_designator USE expression SEMI
    | FOR local_name'attribute_designator USE name SEMI
   ;

// 13.4
enumeration_representation_clause : 
    FOR first_subtype_local_name USE enumeration_aggregate SEMI
   ;

// 13.4
enumeration_aggregate : array_aggregate
   ;

// 13.5.1
record_representation_clause : 
    FOR first_subtype_local_name USE
       RECORD ( mod_clause )?
          ( component_clause )*
       END RECORD ( local_name )? SEMI
   ;

// 13.5.1
component_clause : 
    component_local_name AT position RANGE first_bit DOT_DOT last_bit SEMI
   ;

// 13.5.1
position : static_expression
   ;

// 13.5.1
first_bit : static_simple_expression
   ;

// 13.5.1
last_bit : static_simple_expression
   ;

// 13.8
code_statement : qualified_expression SEMI
   ;

// 13.11.3
storage_pool_indicator : storage_pool_name | NULL | Standard
   ;

// 13.12
restriction :  restriction_identifier
    | restriction_parameter_identifier RIGHT_SHAFT restriction_parameter_argument
   ;

// 13.12
restriction_parameter_argument : name | expression
   ;

// H.7
extended_global_mode : 
    OVERRIDING basic_global_mode
   ;

// H.7.1
formal_parameter_set : 
    formal_group_designator
  | formal_parameter_name
  | LPAREN formal_parameter_name( COMMA formal_parameter_name )* RPAREN
   ;

// H.7.1
formal_group_designator : NULL | ALL
   ;

// H.7.1
formal_parameter_name : 
    formal_subtype_mark
  | formal_subprogram_name
  | formal_access_to_subprogram_object_name
   ;

// H.7.1
dispatching_operation_set : 
    dispatching_operation_specifier
  | LPAREN dispatching_operation_specifier( COMMA dispatching_operation_specifier )* RPAREN
   ;

// H.7.1
dispatching_operation_specifier : 
    dispatching_operation_name LPAREN object_name RPAREN
   ;

// J.3
delta_constraint :   DELTA static_simple_expression ( range_constraint )?
   ;

// J.7
at_clause : FOR direct_name USE AT expression SEMI
   ;

// J.8
mod_clause : AT MOD static_expression SEMI
   ;

// Synthetic rules for non terminals

non_quotation_mark_graphic_character : graphic_character
   ;

non_end_of_line_character : character
   ;

pragma_argument_identifier : identifier
   ;

pragma_argument_aspect_mark : aspect_mark
   ;

subtype_name : name
   ;

static_expression : expression
   ;

parent_subtype_indication : subtype_indication
   ;

static_simple_expression : simple_expression
   ;

discrete_subtype_indication : subtype_indication
   ;

discriminant_selector_name : selector_name
   ;

record_identifier : identifier
   ;

discriminant_direct_name : direct_name
   ;

interface_subtype_mark : subtype_mark
   ;

reference_object_name : name
   ;

indexable_container_object_prefix : prefix
   ;

component_selector_name : selector_name
   ;

base_expression : expression
   ;

key_expression : expression
   ;

tested_simple_expression : simple_expression
   ;

choice_simple_expression : simple_expression
   ;

dependent_expression : expression
   ;

boolean_expression : expression
   ;

selecting_expression : expression
   ;

body_expression : expression
   ;

reduction_identifier : identifier
   ;

reducer_name : name
   ;

initial_value_expression : expression
   ;

subpool_handle_name : name
   ;

label_statement_identifier : statement_identifier
   ;

variable_name : name
   ;

loop_statement_identifier : statement_identifier
   ;

loop_identifier : identifier
   ;

integer_simple_expression : simple_expression
   ;

iterator_name : name
   ;

iterable_name : name
   ;

procedure_name : name
   ;

procedure_prefix : prefix
   ;

formal_parameter_selector_name : selector_name
   ;

block_statement_identifier : statement_identifier
   ;

block_identifier : identifier
   ;

loop_name : name
   ;

label_name : name
   ;

object_name : name
   ;

package_name : name
   ;

function_name : name
   ;

function_prefix : prefix
   ;

ancestor_subtype_indication : subtype_indication
   ;

exception_name : name
   ;

callable_entity_name : name
   ;

generic_package_name : name
   ;

generic_procedure_name : name
   ;

generic_function_name : name
   ;

task_identifier : identifier
   ;

protected_identifier : identifier
   ;

entry_direct_name : direct_name
   ;

entry_identifier : identifier
   ;

entry_name : name
   ;

delay_expression : expression
   ;

task_name : name
   ;

library_unit_name : name
   ;

string_expression : expression
   ;

string_simple_expression : simple_expression
   ;

generic_formal_parameter_selector_name : selector_name
   ;

subprogram_name : name
   ;

package_instance_name : name
   ;

default_subtype_mark : subtype_mark
   ;

aspect_identifier : identifier
   ;

first_subtype_local_name : local_name
   ;

component_local_name : local_name
   ;

storage_pool_name : name
   ;

restriction_identifier : identifier
   ;

restriction_parameter_identifier : identifier
   ;

formal_subtype_mark : subtype_mark
   ;

formal_subprogram_name : name
   ;

formal_access_to_subprogram_object_name : name
   ;

dispatching_operation_name : name
   ;

